## 169. 求众数(easy)
### 题目描述
[博客园](https://www.cnblogs.com/grandyang/p/9001474.html)

给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

示例 1:

	输入: [3,2,3]
	输出: 3
	示例 2:

	输入: [2,2,1,1,1,2,2]
	输出: 2


### 思路

方法一、耗时：20ms

给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

方法二、耗时：24ms

虽然用map记录也能过，但是明显其复杂度高，一个o(n)的解法（貌似是某年408算法题）



### 代码
```
class Solution {
public:
    //20ms
    int majorityElement1(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        return nums[n/2];
    }

    //24ms
    int majorityElement(vector<int>& nums) {
        int res=0, count=0;
        for(int x:nums){
            if(count==0){
                res=x;
                count=1;
            }else if(res==x){
                count++;
            }else{
                count--;
            }
        }
        return res;
    }

};
```
### add

题目：如何在O(n)的时间复杂度内找出数组中出现次数超过了一半的数。
由于本题对时间复杂度有要求，所以可采用以下2种方法。

#### 方法一
每次取出两个不同的数，剩下的数字中重复出现的数字肯定比其他数字多，将规模缩小化。如果每次删除两个不同的数（不管包括不包括最高频数），那么在剩余的数字里，原最高频数出现的频率一样超过了50%，不断重复这个过程，最后剩下的将全是同样的数字，即最高频数。此算法避免了排序，时间复杂度只有O(n)，空间复杂度为O(1)。

#### hash法
首先创建一个hash_map，其中key为数组元素值，value为此数出现的次数。遍历一遍数组，用hash_map统计每个数出现的次数，并用两个值存储目前出现次数最多的数和对应出现的次数，此时的时间复杂度为 O(n)，空间复杂度为O(n)，满足题目的要求。

备注：如果对时间复杂度没有要求，那么可以先对数组排序，然后取中间元素即可。因为如果某个元素的个数超过一半，那么数组排序后该元素必定占据数组的中间位置。（该方法的时间复杂度就是排序用的时间，即最快的排序算法的时间复杂度O(nlogn)）。
