### 202. 快乐数（easy）

[博客园](http://www.cnblogs.com/grandyang/p/4447233.html)

### 题目

编写一个算法来判断一个数是不是“快乐数”。

一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。

示例: 

	输入: 19
	输出: true
	解释: 
	12 + 92 = 82
	82 + 22 = 68
	62 + 82 = 100
	12 + 02 + 02 = 1
 

### 思路

#### 方法一

这道题定义了一种快乐数，就是说对于某一个正整数，如果对其各个位上的数字分别平方，然后再加起来得到一个新的数字，再进行同样的操作，如果最终结果变成了1，则说明是快乐数，如果一直循环但不是1的话，就不是快乐数，那么现在任意给我们一个正整数，让我们判断这个数是不是快乐数，题目中给的例子19是快乐数，那么我们来看一个不是快乐数的情况，比如数字11有如下的计算过程：

	1^2 + 1^2 = 2
	2^2 = 4
	4^2 = 16
	1^2 + 6^2 = 37
	3^2 + 7^2 = 58
	5^2 + 8^2 = 89
	8^2 + 9^2 = 145
	1^2 + 4^2 + 5^2 = 42
	4^2 + 2^2 = 20
	2^2 + 0^2 = 4

我们发现在算到最后时数字4又出现了，那么之后的数字又都会重复之前的顺序，这个循环中不包含1，那么数字11不是一个快乐数，发现了规律后就要考虑怎么用代码来实现，我们可以用set来记录所有出现过的数字，然后每出现一个新数字，在set中查找看是否存在，若不存在则加入表中，若存在则跳出循环，并且判断此数是否为1，若为1返回true，不为1返回false。


#### 方法二


其实这道题也可以不用set来做，我们并不需要太多的额外空间，关于非快乐数有个特点，循环的数字中必定会有4，这里就不做证明了，我也不会证明，就是利用这个性质，就可以不用set了。

### 代码

```
class Solution {
public:
    
    //4ms
    bool isHappy(int n) {
        set<int> s;
        while(n!=1){
            int t=0;
            while(n){
                t+=(n%10)*(n%10);
                n/=10;
            }
            n=t;
            if(s.count(n)) break;
            else s.insert(n);
        }
        
        return n==1;
    }
    
    
    //0ms
    bool isHappy2(int n) {
        while(n!=1 && n!=4){
            int t=0;
            while(n){
                t+=(n%10)*(n%10);
                n/=10;
            }
            n=t;
        }
        
        return n==1;
    }
};
```
