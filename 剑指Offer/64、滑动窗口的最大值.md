## 题目描述

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

## 解题思路
假设窗口大小为w，
- 1、简单的方法：    
遍历数组，从数组第w-1位开始，每次移动一位，并计算窗口w的最大值。
时间复杂度：
计算窗口的最大值需O(w)，移动n-w+1次，时间复杂度为O(nw)

- 2、最大堆方法:     
构建一个窗口w大小的最大堆，每次从堆中取出窗口的最大值，随着窗口往右滑动，需要将堆中不属于窗口的堆顶元素删除。
时间复杂度：
正常情况下，往堆中插入数据为O(lgw)，如果数组有序，则为O(lgn),因为滑动过程中没有元素从堆中被删除，滑动n-w+1次，复杂度为O(nlgn).
- 3、双队列方法：    
最大堆解法在堆中保存有冗余的元素，比如原来堆中元素为[10 5 3]，新的元素为11，则此时堆中会保存有[11 5 3]。其实此时可以清空整个队列，然后再将11加入到队列即可，即只在队列中保持[11]。使用双向队列可以满足要求，滑动窗口的最大值总是保存在队列首部，队列里面的数据总是从大到小排列。当遇到比当前滑动窗口最大值更大的值时，则将队列清空，并将新的最大值插入到队列中。如果遇到的值比当前最大值小，则直接插入到队列尾部。每次移动的时候需要判断当前的最大值是否在有效范围，如果不在，则需要将其从队列中删除。由于每个元素最多进队和出队各一次，因此该算法时间复杂度为O(N)。

## AC代码
```
import java.util.ArrayList;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] num, int size)
    {
        ArrayList<Integer> list = new ArrayList<Integer>();  
        if(num.length==0||size<1){  
            return list;  
        }  
        for(int i=0;i<num.length-size+1;i++){  
            int max = num[i];  
            for(int j=i;j<i+size;j++){  
                if(max<num[j]){  
                    max = num[j];  
                }  
            }  
            list.add(max);  
        }  
        return list; 
    }
}
```